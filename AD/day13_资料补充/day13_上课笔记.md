#### 昨日回顾

```
IO流使用场景
	单独读或者单独写文本数据的时候用字符流,其他情况(拷贝或者操作音视频)用字节流 
字符流处理文本数据的优势
	1,一次可以读多个字节,避免产生乱码
	2,可以直接写出一个字符串
	3,他的字符缓冲区可以一次读一行
转换流
	其实是字符流 + 编码表
	1,可以指定编码
	2,可以将字节流转成字符流
对象操作流
	可以直接读写一个对象到文件
	1,对象必须实现序列化接口
	2,读到最后没有数据了会被一个EOFException
Properties
	本质是一个map集合,是唯一一个和IO有关的,可以直接从文件中读写数据
	load(输入流)
	getProperty()
打印流
	java中的单身汉流  只负责输出
	分类
		字节打印流 PrintStream  很少使用
		字符打印流 PrintWriter  用的比较多(web阶段)
	特点
		都有print和println()方法,可以原样输出数据,println还可以自动换行
	 	PrintWriter如果后面加一个true的参数,可以实现自动刷新
	
```

#### 相关概念

##### 并发并行

```
⚫ 并行：在同一时刻，有多个指令在多个CPU上同时执行。  双核电脑
⚫ 并发：在同一时刻，有多个指令在单个CPU上交替执行    单核电脑
```

##### 进程线程

```
进程 
	内存中正在运行的一个程序
线程
	这个程序的一条执行路径
多线程
	一个程序有多条执行路径
分类
	单进程单线程:一个人在一个桌子上吃饭
	单进程多线程:多个人在一个桌子上吃饭 资源共享的时候会发生冲突抢夺(线程安全问题)
	多进程单线程:多个人每个人都在自己的桌子上吃饭 不同桌子上的人说话不方便 (线程间通信)
	
	window:开桌子开销大,鼓励大家都在一个桌子上吃饭
	Linux:开桌子开销小,鼓励每个人都在自己的桌子上吃饭
	
单线程和多线程的区别
	单线程:安全性高,但是效率低
	多线程:安全性低,但是效率高
```

##### 应用场景

```
1,共屏软件同时共屏给多个学生
2,迅雷开启多个线程一起下载
3,qq同时和多个人视频
4,服务器同时处理多个请求
```



#### 实现方式

##### 继承Thread类

```
⚫ 定义一个类MyThread继承Thread类
⚫ 在MyThread类中重写run()方法
⚫ 创建MyThread类的对象
⚫ 启动线程
```

##### 实现Runnable接口

```
⚫ 定义一个类MyRunnable实现Runnable接口
⚫ 在MyRunnable类中重写run()方法
⚫ 创建MyRunnable类的对象
⚫ 创建Thread类的对象，把MyRunnable对象作为构造方法的参数
⚫ 启动线程
```

##### 实现Callable接口

```
⚫ 定义一个类MyCallable实现Callable接口
⚫ 在MyCallable类中重写call()方法
⚫ 创建MyCallable类的对象
⚫ 创建Future的实现类FutureTask对象，把MyCallable对象作为构造方法的参数
⚫ 创建Thread类的对象，把FutureTask对象作为构造方法的参数
⚫ 启动线程
⚫ 再调用get方法，就可以获取线程结束之后的结果
```

##### 三者区别

```
继承Thread类
	好处:可以直接使用Thread类中的方法,代码比较简单
	弊端:如果已经有了父类,就不能使用这个方法
	
实现Runnable接口
	好处:即使自定义的类有了父类,还是可以实现接口的,接口可以多实现,并且共享资源非常方便
	弊端:不能直接使用Thread类中的方法,需要先获取线程对象,才能使用里面的方法,代码稍微复杂

实现Callable接口
	好处:可以抛出异常,还可以有返回值
	弊端:代码比较复杂
```



#### 相关方法

##### 常用方法

```
获取设置线程名称
    getName()获取线程名称
    setName()设置线程名称

获取当前的线程对象
    currentThread()获取当前线程(静态方法)
    
线程休眠
    sleep(毫秒值);静态方法,让当前线程休眠指定毫秒
```

##### 其他方法

```
线程的优先级
⚫ public final void setPriority(int newPriority) 设置线程的优先级,默认是5,越高优先级越大
⚫ public final int getPriority() 获取线程的优先级

public final void setDaemon(boolean on)：设置为守护线程
void join()  等待这个线程死亡
```

#### 线程安全

##### 原因分析

```
1,要有共享的数据
2,要有多个线程
3,多个线程同时操作共享的数据

出现的问题
	重复数据:相同的票被卖了多次
	非法数据:卖出负数的票
```

##### 解决方案

```
用一把锁把操作共享数据的代码锁起来,保证任意时刻只有一个线程在执行

方案一:同步代码块
	格式:synchronized(锁对象){操作共享数据的代码}
	
方案二:同步方法
	非静态的同步方法:把可能会出现问题的代码抽成一个方法,在方法上面加上synchronized关键字
	静态的同步方法:就是在上面的非静态同步方法上面加上一个static关键字
	
方案三:Lock锁
	创建锁,加锁,释放锁

注意点:
	锁的地方要所对
	锁对象要唯一
```



#### 死锁问题

##### 出现原因

```
1,有多把锁
2,有多个线程
3,有同步代码块的嵌套
```

##### 解决方案

```
无解,尽量避免
```



#### 等待唤醒

##### 出现目的

```
默认情况下,cpu是随机切换线程的,如果我们想让线程有规律的执行,就需要线程间协调通信
```

##### 常用方法

```
void wait()  当前线程等待
void notify() 随机唤醒当前锁上等待的线程
void notifyAll() 唤醒当前锁上等待的所有的线程

这个几个方法必须要有锁对象来调用,并且需要写在同步代码块或者同步方法中
```

