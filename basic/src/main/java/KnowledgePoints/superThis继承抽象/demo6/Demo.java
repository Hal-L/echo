package KnowledgePoints.superThis继承抽象.demo6;

/*
    继承:
        1.格式:
            public class 类A extends 类B{

            }

           类A: 子类
           类B: 父类

        2.继承的特点:
            1.子类继承父类,只能继承父类的非私有属性和非私有方法

            2.子类继承父类,只能单继承,不能多继承,但是可以多层继承
                记忆: 一个人只能拥有一个亲爹
        3.继承后的成员变量访问特点
            成员变量不重名: 正常使用,没有影响
            成员变量重名:
                就是使用就近原则:
                    如果局部变量的位置有,就直接使用局部变量,如果局部变量位置没有,就去成员位置找,如果成员位置有该变量,就直接使用,如果成员位置
                    没有该变量,就去父类中找,如果父类中有改变了,就直接使用,如果父类中没有,就会报错

               如果想要在子类中访问父类的成员变量,就可以使用super关键字
                格式:  super.父类成员变量名

        4.继承后的成员方法方法特点
            成员方法不一样: 正常使用,没有影响
            成员方法一样:优先调用子类中的方法

            方法重载: 在同一个类中,如果方法名相同,参数不同,就是方法的重载
            方法重写: 如果子类中出现了和父类中一模一样的方法(包括返回值类型,方法名,方法的参数)

            什么时候需要重写?为什么要重写?
                当父类方法的功能无法满足子类需求的时候,就需要方法的重写
                1.子类具有了特有的功能
                    例如:
                        Person类中有一个运动的方法,运动方法的功能就是跑步
                        Student子类运动方法的功能是游泳
               2.子类在父类的基础上额外添加功能
                     例如:
                        Person类中有一个跑步的方法,跑步方法的功能就是跑3圈
                        Student子类跑步方法的功能是要跑10圈

            使用注解标识重写的方法
                @Override,使用@Override标识的方法一定是一个重写的方法,如果不能使用@Override注解标识,就不是方法重写

            如果在子类中想要调用父类的方法,就可以使用super
                格式: super.父类方法名(参数)

            注意:
                1.子类和父类出现一模一样的静态方法,不是重写的方法
                2.凡是重写的方法,都可以使用@Override注解修饰
                3.子类方法覆盖父类方法，必须要保证权限大于等于父类权限。
                 private(本类中)  <   (default 默认)(同一个包)  <  protected(本类和子类)  <  public(当前项目中)
                            本类          同一个包     本类和子类(不同包)     不同包
            private         true           false        false               false
            默认             true          true         false                false
            protected        true          true         true                false
            public          true            true        true                true


        5.继承后的构造方法:
            特点:
                1.构造方法不能被继承,但是可以使用
                2.怎么使用父类的构造方法?
                    使用super关键字
                        调用父类的空参构造: super()
                        调用父类的有参构造: super(参数)

                        如果子类在访问父类数据之前就可以使用父类的构造方法给父类的属性初始化

               3.子类中的构造方法默认会调用父类的空参构造方法
 */
public class Demo {

    public static void main(String[] args) {

        // 调用Zi类的空参构造方法创建对象
//        Zi zi = new Zi();

        // 调用Zi类的有参构造方法创建对象
        Zi zi = new Zi(10,"黑马程序员");
        zi.show();

    }
}
