package KnowledgePoints.myInterface.demo9;
/*
接口:
    1.概述:就是一种公共规范标准
    2.定义接口:
        public interface 接口名{

        }

    3.实现接口:
        1.创建一个类
        2.实现该接口
            public class 类名 implements 接口名{

            }
    4.接口中的成员
        jdk1.7及其以前只能写:
            常量
                默认修饰符: public static final
                1.接口中的常量可以供接口直接使用
                2.接口中的常量可以供子类和子类对象使用

            抽象方法
                // 接口中的抽象方法的默认修饰符: public abstract
                    public abstract void method();
                    public          void method1();
                           abstract void method2();
                                    void method3();

                1.如果实现类是普通类,就必须实现接口中的所有抽象方法
                2.如果实现类是抽象类,就可以不实现接口中的抽象方法

        jdk1.8额外添加了:
            默认方法:需要加default
                格式:
                    public default 返回值类型 方法名(参数列表){

                    }

                1.接口中的默认方法可以供子类对象调用
                2.接口中的默认方法可以供子类重写,但是重写的时候不需要加 default

            静态方法
                public static 返回值类型 方法名(参数列表){

                }

            1.静态方法只能供接口直接使用,实现类不能使用

        jdk1.9额外添加了:
            私有的方法
                private 返回值类型 方法名(参数列表){

                }

                私有方法只能供接口中的默认方法使用

            私有静态方法
                private static 返回值类型 方法名(参数列表){

                }

                私有静态只能供接口中的默认方法\私有方法\静态方法使用

    接口和类之间的关系:实现关系
            单实现:一个类实现一个接口
            多实现:一个类实现多个接口
             格式:
                public class 类名 implements 接口1,接口2,...{

                }

             1.多个接口中没有重名的抽象方法,实现类需要全部实现所有抽象方法
             2.多个接口中有重名的抽象方法,实现类只需要实现一个抽象方法

             3.多个接口中没有重名的默认方法,实现类就正常使用,不需要重写默认方法
             4.多个接口中有重名的默认方法,实现类必须重写重名的默认方法

             5.静态方法只能供接口直接使用,跟实现类无关,正常使用
             6.私有方法只能供接口的默认方法\私有方法\静态方法使用,跟实现类也无关,正常使用

    接口和接口之间的关系: 继承关系
        单继承:一个接口继承一个接口
        多继承:一个接口同时继承多个接口
        多层继承:一个接口继承另一个接口,而另一个接口又继承另一个接口

            单继承:
                public interface 接口A extends 接口B{

                }

                接口A: 子接口
                接口B:  父接口

           多继承:
                public interface 接口A extends 接口B,接口C,...{

                }
                接口A: 子接口
                接口B\C\...:  父接口

          多层继承:


       类可以继承一个类也可以实现一个接口


    注意:
        1.接口也是一种引用数据类型
        2.接口编译之后也会有.class文件
        3.接口中不能有构造方法,只能通过其实现类(子类)来创建





    多态: 多个不同的对象以自己的方式响应相同名称的方法
    多态的三个条件:
        1.继承(实现)
        2.方法的重写
        3.父类的引用指向子类的对象
    多态中的成员访问特点:
        成员变量: 编译看左边,运行看左边
        成员方法:
            非静态方法: 编译看左边,运行看右边
            静态方法:编译左边,运行看左边
    多态的好处和使用
        一般来讲,都是把父类(接口)的引用作为方法的参数,用来接收该父类(接口)的所有子类(实现类)对象

    父类的引用不能调用子类的特有方法和属性,所以又了向下转型
    向下转型: 把父类类型 转换为 子类类型   强制转换
             子类类型 对象名 = (子类类型)父类的引用;

    instanceof关键字     对象名 instanceof 数据类型  判断前面的对象是否属于后面的数据类型,如果是,返回true,否则返回false

    向上转型: 把子类类型  转换为 父类类型     自动完成

例子:
        已知动物类（姓名，年龄，吃饭，睡觉），它有两个子类，分别是猫类和狗类。
		不同的是猫吃鱼，狗吃肉。
		经过马戏团的培训后，部分猫会跳高，部分狗也会跳高。
		请写代码实现。

		思路:
		    动物类: 抽象类
		        属性: 姓名  年龄
		        方法: 吃饭(抽象的方法),睡觉

		    猫类:  继承动物类
		        方法:  重写吃饭的方法

		    狗类: 继承动物类
		        方法: 重写吃饭的方法

		    跳高的接口:
		        跳高的方法  ---> 抽象方法

		     跳高猫类: 继承猫类,实现跳高的接口
		          方法: 实现接口中的跳高方法

		     跳高狗类: 继承狗类,实现跳高的接口
		          方法:实现接口中的跳高方法


    继承有局限性,接口具备扩展性
    一个类继承了一个类,就不能再继承别的类
    一个类实现了一个接口,就还可以继承别的类,也可以实现别的接口

 */
public class Demo9 {
    public static void main(String[] args) {





    }
}
