#### 昨日反馈

```
***	晚上即使预习了，第二天有可能也忘了，然后老师第二天上课的时候可以先放视频后练题吗？不然你直接敲代码可能让我有点懵
*** 老师可以讲慢点,给时间让我们消化消化
***	请了两天假,我感觉自己完完了
***	老师做总结做笔记打字的时候打慢一点
```

#### 昨日回顾

```
day17类加载 过程 字节码文件加载到内存的一个过程
类加载器 工具 负责加载字节码文件 getResourceAsStream() 加载src下面的资源文件
反射
	概念:反向获取 运行的时候,动态的获取属性,调用方法
	前提:获取Class对象 Class.forName("全类名")
	使用:
		获取构造器:getConstructor()
		获取Field对象:getField() getDeclareField()
		获取Method对象:getMethod()  --invoke()
javaBean  封装数据 规范
	类使用公共进行修饰
	提供私有修饰的成员变量
	为成员变量提供公共的set和get方法
	提供无参的构造
```

#### XML语法

##### 1.概念

```
可扩展的标记型语言
```

##### 2.作用

```
主要是用于存储数据,一般用在配置文件
```

##### 3.语法

```
文档后缀名是.xml
第一行必须是文档声明
有且只有一个根标签
属性值必须用引号(单双都可以)引起来
标签必须正确的关闭
标签区分大小写
```

##### 4.组成

```
文档声明
	固定的
标签
	可以是中文(Unicode字符)
	标签体:一对尖括号括起来的内容,要么是纯文本要么是子标签
属性
	作用就是为了补充,描述当前的标签
文本
	CDATA区:<![CDATA[文本内容]]>
	
练习:展示如下数据:
黑马程序员
	javaEE
		就业1班
		就业2班
		就业3班
	前端
		就业1班
		就业2班
	大数据
		就业1班
```

#### XML解析

##### 解析方式

```
DOM
	方式:将标记语言文档一次性的加载到内存,在内存中形成一个dom树
	优点:操作方便,可以对文档进行增删改查的操作
	弊端:占内容,可能导致内存溢出
SAX
	方式:逐行读取,读到哪就操作到拿,操作完之后就释放内存,再去读下一行
	优点:不占内存
	弊端:只能读取,不能增删改,一般用在移动端
```

##### 操作思想

```
将xml文档中的所有的标签和属性和文本抽成对象,用面向对象的方式去操作它(因为对象是有属性和方法)
跟后面JavaScript操作html的思想是一模一样
```

##### DOM4J解析

```
节点中的方法
	elements() 获取当前元素的子元素
	element(String name) 根据子元素的名称或者子元素(如果有多个默认获取第一个)
	getName() 获取元素的名称
	attributeValue(String name) 获取当前元素下某个属性的值
	elementText(String name) 获取指定子元素的文本值,参数是子元素的名称
	getText()	获取当前元素的文本值
```

##### XPath路径

```
作用:
	快速的直接定位到元素,是一种路径写法

使用
	1,导入Xpath的包
	2,调用方法,里面传入路径

方法
	List selectNodes("表达式") 使用xpath作为参数查找多个节点
	Node selectSingleNode("表达式") 使用xpath作为参数查找一个节点(默认获取的是第一个)
	
xpath表达式写法
	绝对路径表达式  以/开头的就是绝对路径
	相对对路径表达式 不以/开头的就是绝对路径,相对路径是相对于当前元素
	全文检索路径表达式 // 代表忽略中间路径,不管有多少层
```



#### DTD约束

##### 概念

```
目的
	xml存储数据既可以使用标签,也可以使用属性,使用约束就可以统一规范,便于解析
	使用技术的手段,规定xml中只能出现的标签和属性,不能出现其他无关的属性
分类
	dtd:简单,只能约束标签名和属性名,不能约束标签和属性的内容
	Schema:复杂,既能约束标签名和属性名,也能约束标签和属性的内容 
```

##### 语法

```
定义元素
	语法:<!ELEMENT 元素名称 约束>
	
	复杂元素:有子元素的元素
		格式:<!ELEMENT 元素名称 (子元素)>
		
		表示元素出现的次数的正则符号
			+:表示出现一次或者多次(至少一次)
			?:表示0次或者一次
			*:表示0次或者多次(任意次)
		子元素直接使用逗号隔开
			表示子元素出现的顺序
		子元素直接使用 | 隔开
			表示子元素只能出现其中任意一个
	
	简单元素:没有子元素的元素
		格式:<!ELEMENT 元素名称 (类型)>
			
			(#PCDATA) 表示标签体是字符串类型
			ANY 表示标签体是任意类型
			EMPTY 表示没有标签体 比如:<gender/>
定义属性
	<!ATTLIST 元素名称 属性名称 属性类型 属性的约束>
	
	属性类型
		CDATA:字符串类型
			例子:<!ATTLIST 商品 类别 CDATA #REQUIRED>
				<商品 类别="abc"></商品>
		枚举:值在固定范围,并且每次只能出现其中一次
			例子:<!ATTLIST 商品 颜色 (红色|绿色|黄色) #REQUIRED>
				<商品 颜色="黄色"></商品>
		ID:值只能是下划线或者字母开头,并且不能重复
			例子:<!ATTLIST 商品 编号 ID #REQUIRED>
				<商品 编号="A001"></商品>
	
	属性的约束
		#REQUIRED 属性值是必须的
		#IMPLIED 属性不是必须的,可有可无
		#FIXED value 属性值是固定的
			例子:<!ATTLIST 商品 品种 CDATA #FIXED "ABC">
				<商品 品种="ABC"></商品>
	    直接值  不写属性,使用的是默认值,如果你写了,就是你设置的值
	    	例子:<!ATTLIST 商品 品种 CDATA "ABC">
				 <商品/> 虽然你没写属性,但是它是属性的,属性值默认是"ABC"
```

##### 引入

```
内部dtd:将约束规则定义在xml的文档中
外部dtd:将约束规则定义在外部的dtd文件中
	本地:<!DOCTYPE 根标签名 SYSTEM "dtd文件的位置">
	网络:<!DOCTYPE 根标签名 PUBLIC "dtd文件的名字" "dtd文件的URL">
```



#### Schema

##### 概念

```
是约束界龙头老大,可以对数据类型做更加精准的限制,文件命以.xsd结尾
```

##### 语法

```
约束标签
	<element name="" type="">
约束属性
	<attribute name="" type="">
```

##### 引入

```
1,明确根元素来自哪个名称空间
2,明确这是一个被约束的文件
3,明确引入的名称空间和哪个xsd文件对应
```

